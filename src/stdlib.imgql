// Copyright 2018 Vincenzo Ciancia.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//
// A copy of the license is available in the file "Apache_License.txt".
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Prefix and infix forms for boolean operators
let &(a,b) = and(a,b)       
let |(a,b) = or(a,b)
let !(a) = not(a)

// "Through" operator in infix form; used internally to define mayReach and
// surrounded 
// a ~> b is true at point x if there is a connected component C of
// the points that are true in a, with C containing one point which is true in b 
let ~>(a,b) = through(b,a)      

// Prefix operator form for near, interior, and external boundary
let N(a) = near(a)
let I(a) = interior(a)
let B+(a) = (near(a)) \ a

// Set theoretic subtraction
let \(a,b) = and(a,not(b))

// Reachability derived operators
let mayReach(a,b) = N((b ~> N a) | a)
let touch(a,b) = a ~> N b
let grow(a,b) = (a | touch(b,a))
let T(a,b) = touch(a,b)

let surrounded(a,b) = a \ mayReach(not(a | b),not(b)) 
let S(a,b) = surrounded(a,b)

// Some shorthands 
let .< (n,i) = (n .<= i) & (!(n .= i))
let .> (n,i) = (n .>= i) & (!(n .= i))
let <. (i,n) = n .> i
let <=. (i,n) = n .>= i
let >. (i,n) = n .< i
let >=. (i,n) = n .<= i
let =. (i,n) = n .= i

let .* (a,b) = b *. a
let .+ (a,b) = b +. a


// Distance operators
let pdt(x) = mask(dt(x),dt(x) >. 0)
let distgeq(x,y) = x .<= pdt(y)
let distleq(x,y) = x .>= pdt(y)

// More advanced functions
let smoothen(a,x) = distleq(x,distgeq(x,!a))

let ~ (a,b,rad,bins) = crossCorrelation(rad,a,b,tt,min(b),max(b),bins)

let booleanToNumber(k,x) = mask(constant(k),x)

let norm(k,x) = (k .* x) /. max(x)